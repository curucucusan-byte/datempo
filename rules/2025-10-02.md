Bora dar tração ao ZapAgenda sem romantizar: produto tem que resolver uma dor com menos fricção que WhatsApp puro + Google Calendar soltos. Abaixo está um plano prático: o que construir, como achar/ser achado, e como crescer de forma contínua.

1) Funcionalidades “killer” (prova de valor em 30s)

Link de agendamento 1-tap: zap.agenda/meu-negocio abre WhatsApp com mensagem pré-preenchida (`CONFIRMAR {TOKEN} {DATA_LOCAL}`), retorna slots disponíveis e confirma em 3 toques.

Confirmação e lembretes automáticos no WhatsApp (Cloud API): cliente inicia a sessão; operamos com janela de segurança de 22h (nunca iniciamos conversa). Lembretes curtos agregados com botões “remarcar”, “cancelar”, “ver rota”.

Estados claros (`PENDING → TENTATIVE/CONFIRMED → CANCELLED/EXPIRED`) e links de aprovação seguros para o dono.

Sincronização bi-direcional com Google Calendar: bloqueio de conflitos, horários de almoço/folga, buffers antes/depois.

Checkout no ato (opcional): habilitar pagamento obrigatório por serviço/agenda, com confirmação automática pós-webhook (`paid|approved`) e reembolso rastreável.

Regrinhas inteligentes: duração por serviço, limite/dia, janela de antecipação, no-show fee (mesmo que só informativa), capacidade por recurso (ex.: sala/equipamento).

Links “Add to Calendar” universais: ICS + Google + Apple; QR nos cartões/pôsteres.

Página pública leve: SEO básico (Schema.org LocalBusiness + Service + Event), depoimentos, horário, CTA para WhatsApp.

Painel do dono: rebook em 1 clique, lista de espera, bloqueios rápidos, histórico por cliente.

Relatórios simples: compare “sem ZapAgenda vs com ZapAgenda”: no-shows ↓, ocupação ↑, ticket médio, LTV por cliente.

2) Engenharia de busca (dentro do app e para ser encontrado)

No app (operacional):

Indexação: Postgres + GIN trigram (pg_trgm) para busca por nome/telefone/apelido/placa com tolerância a erro.

Ranking: recência de contato × frequência × valor do cliente (RFM simples).

Query understanding: interpretar mensagens no WhatsApp como comandos (“quarta 15h corte masculino 30min”) → parser de data natural (pt-BR) + fallback.

Disponibilidade: pré-computar e cachear “próximos N slots” por serviço/recurso (Redis) para resposta instantânea no WhatsApp.

Deduplicação: merge de contatos por e164(telefone) + similaridade de nome.

Observabilidade da busca: logar consultas “sem resultado”, latência P95, termos com erro → alimentar roadmap.

Para ser achado (externo):

SEO local: schema LocalBusiness + hasMap/geo, páginas por serviço/cidade/bairro (evitar doorway; conteúdo real: preço, duração, política de atraso).

Avaliações: integração com Google Business Profile: após atendimento “Avalie em 10s” (NPS→review).

Snippet de agendamento embutível: widget <iframe>/script para sites/Instagram bio.

3) Growth loops (crescimento que se retroalimenta)

Loop de convite do cliente: no lembrete de confirmação, incluir botão “Indicar amigo → ganha X% de desconto”. Cupom de atribuição por telefone.

Loop do profissional: “Fez 20 agendamentos? Desbloqueie selo ‘Atende pelo WhatsApp’ + badge no site.”

Loop de reativação: 30/60/90 dias sem visita? WhatsApp com 2 slots prontos + CTA.

Loop de conteúdo: gerador de micro-posts (antes/depois, dicas semanais) com calendário editorial e CTA para o link de agendamento.

4) Distribuição (onde as pessoas já estão)

WhatsApp Business: catálogo de serviços + respostas rápidas com {{meu_link_de_agenda}}.

Parcerias de nicho: barbearias, clínicas, estúdios—comece com 5 pilotos que topem dar depoimentos e permitir logo do ZapAgenda no rodapé.

Marketplaces e comunidades: grupos locais (Facebook/WhatsApp), Google Maps (Posts), perfis no Instagram com botão “Reservar” → Link in bio.

Product-led sales: versão grátis útil (1 agenda, 1 recurso, 50 agendamentos/mês) e upsell claro (multirecurso, lembretes extras, relatórios, equipe).

5) Confiança & compliance (o que derruba concorrente desatento)

LGPD: base legal = execução de contrato + consentimento para marketing; opt-out em 1 toque; DPA simples.

Política do WhatsApp: nunca iniciar conversa (sem HSM/template); apenas responder dentro da janela operacional de 22h. Marketing apenas com opt‑in por canais alternativos.

Uptime e exportação: status page simples, exportar .csv e .ics; nunca “prender” o usuário.

Segurança: webhook assinado, rotating tokens, least-privilege nos scopes do Google.

**Higiene imediata para Cloud API**

- Remover Z-API/Twilio do código, `.env` e documentação; único canal oficial passa a ser WhatsApp Cloud API.
- Criar checklist de onboarding com `WA_META_TOKEN`, `WA_PHONE_NUMBER_ID`, `WA_WABA_ID`, `WA_VERIFY_TOKEN`, `WA_GRAPH_BASE` e (opcional) `META_APP_SECRET`.
- Atualizar mensagens padrão para respeitar a janela operacional de 22h e consolidar confirmações em uma única resposta.
- Expor no painel o estado de cada agendamento (PENDING/TENTATIVE/CONFIRMED/EXPIRED/CANCELLED) e o log de mensagens.
- Definir template de webhook seguro para o PSP escolhido (`paymentWebhookSecret`, retry/idempotência) e sinalizar `paid|approved` → `CONFIRMED` de forma automática.

6) Métricas que importam (North Star + diagnósticas)

North Star: Sessões confirmadas por semana por conta.

Ativação: % que conecta Google Calendar + cria 1 serviço + confirma 1 sessão (com guard de 22h em vigor).

Retenção 8/12 semanas; No-show rate; Tempo médio para confirmação; CAC por canal; % reviews geradas.

7) Testes rápidos (duas semanas por ciclo)

A/B do fluxo WhatsApp: 2 vs 3 toques até confirmar.

Copy dos lembretes: “curto+botões” vs “com detalhes e mapa”.

Página pública: seção “preço/duração” acima da dobra vs abaixo.

Reativação: mensagem com dois horários prontos vs link geral.

8) Stack técnica sugerida (enxuta e escalável)

Core: Next.js/React, Yarn; Postgres (pg_trgm), Redis; fila (BullMQ).

Search externa (quando precisar): Meilisearch para autosuggest e filtros por serviço/recurso.

Mensageria: WhatsApp Cloud API (Meta) com logs + tokens; remover provedores legados (Z-API, Twilio).

Infra: Vercel/Fly + banco gerenciado; feature flags + Sentry.

ETL leve: jobs noturnos para KPIs e churn-risk.

9) Go-to-market em 30 dias (checklist)

Semana 1–2

Link de agendamento 1-tap, confirmação + lembretes, sync Google, página pública com schema.

5 pilotos ativos; métricas instrumentadas.

Semana 3

Reativação 30 dias; convite por indicação; widget embutível; depoimentos.

Semana 4

SEO local (páginas por serviço/bairro), reviews no Google, comparativo “com vs sem ZapAgenda” no painel, anúncio leve em comunidades locais.

10) “Extras” que viram diferencial

Fila inteligente: se cliente cancela, notificar lista de espera por ordem de proximidade.

Proteção a furo: pagamento simbólico para segurar horário (mesmo que “modo estudo” sem cobrar de fato).

Lembrete com rota: deep link Maps com duração do serviço e hora de chegada sugerida.

Micro-CRM: tags e notas por cliente; recomendação de próxima visita com base no histórico.

Quer que eu transforme isso em um mini-roadmap de issues (com títulos, critérios de aceitação e métricas de sucesso) para você copiar no seu repositório?

Você disse:
e freemium?
O ChatGPT disse:
Pensou por 13s

Bora de freemium pro ZapAgenda — com tesoura de custos numa mão e alavanca de upgrade na outra. A regra de ouro: o grátis resolve a dor básica com elegância; o pago reduz atrito, economiza tempo e faz dinheiro. Aqui vai um desenho completo: limites, alavancas, métrica e engenharia por trás.

Camadas sugeridas (pt-BR, preços de referência)

Grátis (Free) – R$ 0/mês

1 agenda conectada (Google)

50 agendamentos/mês

WhatsApp incluído: 50 mensagens/mês

Sem lembretes automáticos

Starter – R$ 49/mês

Até 3 agendas conectadas (Google)

300 agendamentos/mês

WhatsApp incluído: 300 mensagens/mês (excedente por uso)

Lembretes automáticos por WhatsApp: até 2 por agendamento

Pagamentos no ato: opcional (confirma após pagamento aprovado)

Pro – R$ 99/mês

Até 20 agendas conectadas (Google)

1.000 agendamentos/mês

WhatsApp incluído: 1.000 mensagens/mês (excedente por uso)

Lembretes automáticos por WhatsApp: até 3 por agendamento

Reviews Google; no‑show com pagamento no ato

SLA e status page

Funis e metas (ocupação meta, no-show alvo)

Integrações extras (ERP/contábil, multi-unidade)

Mensagens WhatsApp/mês: 8.000

Suporte priorizado

Observação: valores são âncoras; ajuste após 10–20 clientes pagantes. Sempre ofereça teste Pro 14 dias sem cartão.

O que fica no grátis (deliberação de produto)

Experiência mágica: link único + confirmação por WhatsApp + sync Google. Isso precisa ser impecável.

Limites visíveis: contador de agendamentos e de mensagens no topo do painel (“Você usou 38/50 este mês”).

Marca d’água elegante: selo discreto na página pública e no final das mensagens (“Feito com ZapAgenda”).

Alavancas de upgrade (sem ser chato)

Fadiga operacional: Starter libera 3º lembrete, reagendamento 1-tap e reviews automáticas.

Dinheiro na mesa: Pro libera reativação (clientes perdidos voltam), lista de espera, SEO local que traz novos clientes.

Escala: Pro eleva limites e libera integrações.

Gating por limites (evita abuso e dá sensação de avanço)

Agendamentos/mês: bloquear novas marcações quando exceder; permitir edição/cancelamento. Mostrar CTA de upgrade.

Mensagens WhatsApp/mês: no freemium, ao atingir o teto, cair para SMS/e-mail (se configurado) ou só notificação no app.

Agendas/serviços: “slot reservado” visível no UI com cadeado: criar é possível, ativar só no plano acima.

Recursos caros (reativação, SEO páginas por bairro, webhooks): apenas pago.

Custos vs. preço (para não tomar prejuízo)

WhatsApp: operar com janela de 22h reduz custo (sem iniciar conversa). Controlar volume por plano e usar e-mail/SMS quando a sessão não estiver válida.

Infra: Postgres + Redis + hospedagem. O principal custo variável será mensageria. Use rate limits por conta e batching onde couber.

Suporte: restrinja canais por plano (e-mail no Free, chat no Pro+).

Métricas do modelo freemium

North Star: sessões confirmadas/semana por conta.

Ativação (D0-D1): % que conecta Google + cria 1 serviço + confirma 1 sessão.

Upgrade rate: % de Free→Pago em 30 dias (meta inicial 3–5%).

ARPA: receita média por conta paga; Gross Margin por plano.

No-show rate: queda no no-show após lembretes (meta −20%).

Mensagens/Agendamento: controlar 1,8–2,5 msg por sessão (evitar spam e custo alto).

Retenção mensal: Free (30%) | Starter (85%) | Pro (90%+) como alvo.

Triggers de upgrade (contextuais, não modais chatos)

Evento “lotou”: “Você atingiu 50 agendamentos/mês. Liberar +250 e reativação automática por R$ 39?”

Evento “no-show”: após 2 furos no mês no Free, sugerir 3º lembrete e lista de espera (Starter/Pro).

Evento “perdeu cliente”: cliente inativo há 60 dias → banner “reative em 1 clique (Pro)”.

Evento “achabilidade”: ao publicar página pública, mostrar prévia de SEO local com cadeado para os recursos avançados.

Anti-abuso e qualidade

Quota dura por IP/conta no Free (evita fazenda de spam).

Respeitar cooldown e guard de 22h entre mensagens para evitar bloqueios.

Verificação de domínio/negócio no Pro (melhora entregabilidade).

Backoff quando provedor responde erro de categoria/consent.

Onboarding orientado a valor (15 minutos)

Conectar Google Calendar

Definir 2 serviços (duração + buffer)

Ativar lembretes (com guard 22h habilitado)

Gerar link público + testar um agendamento “fantasma”

Importar 20 contatos recentes (CSV/Google) e já agendar 2 slots de teste
→ Ao final: mostrar “Impacto estimado”: no-show −X%, ocupação +Y%.

Engenharia para cobrar e medir sem dor

Feature flags por plano (plan: free|starter|pro|biz) + quota service (agendamentos, mensagens, agendas).

Eventos de billing: booking.confirmed, message.sent, quota.hit, plan.upgrade, plan.downgrade.

Hard/soft caps: hard para mensagens e agendamentos; soft para SEO/exports (fila com prioridade baixa no Free).

Pró-rata em upgrades no meio do ciclo; downgrade só no próximo ciclo, com pré-checagem de limites.

Experiência “sem cartão” nos 14 dias Pro → coletar cartão após atingir 70% da cota de mensagens ou no dia 12.

Experimentos (rápidos e mensuráveis)

Teste A/B: “50 agendamentos + 100 mensagens” vs “100 agendamentos + 50 mensagens” no Free (qual converte mais?).

Teste de banner: “Reative clientes perdidos (Pro)” vs “Ganhe até +12% ocupação (Pro)”.

Preço: R$ 39 vs R$ 49 no Starter em cidades grandes.

Comunicação clara (sem burocratês)

Tabela simples no site com tique/cadeado e contadores.

Calculadora “Quanto você gasta com faltas?” → “Pro paga o plano em X dias”.

# ZapAgenda – Regras de Negócio e Pendências

## 1. Entidades Centrais e Fontes de Dados
- **Account** (`src/lib/account.ts`): guarda o estado da assinatura do SaaS, preferências de lembrete, lista de `linkedCalendars`, além de `activeCalendarId` e `lastCalendarSwapAt`. Contas novas começam no plano `pro` em modo teste de 3 dias (`DEFAULT_ACTIVE_PLAN_ID`).
- **LinkedCalendar** (`src/lib/google.ts`, `src/app/api/account/google/route.ts`): espelha o vínculo com um calendário Google contendo `{ id, summary, ownerUid, slug, description, whatsappNumber, active }`.
- **Appointment** (`src/lib/store.ts`): agenda gravada no Firestore (coleção `appointments`) ou no arquivo local `data/appointments.json`, com `{ id, slug, customerName, customerPhone, startISO, endISO, ownerUid?, createdAt, reminderSentAt? }`. Para pré-pagamento, ampliar com campos `paymentRequired`, `paymentStatus`, `paymentProvider`, `paymentIntentId`, valores (`paymentAmount`, `paymentCurrency`) e registros de `paidAt`/`refundAt`.
- **Payments & Subscriptions** (`src/lib/payments.ts`): coleções em Firestore separadas para `payments` (Pix avulso) e `subscriptions` (cartão) via Stripe. Cobre apenas a cobrança do ZapAgenda; para pré-pagamento de clientes finais, `Appointment` armazena identificadores do PSP (`paymentIntentId`, `paymentStatus`).
- **Sessions & Auth** (`src/lib/session.ts`): gerencia cookies de sessão Firebase (`zapagenda_session`) válidos por 5 dias.
- **Leads** (`src/app/api/lead/route.ts`): captação opcional armazenada no Firestore ou no arquivo `leads.dev.json`.

### 1.1 Status, tokens e sessão (22h)

- `PENDING`: criado via formulário público; segura o slot pelo `holdTTLMinutes` até o cliente iniciar a conversa no WhatsApp.
- `TENTATIVE`: evento provisório no Google Calendar aguardando aprovação quando `confirmationMode=manual_by_owner`.
- `CONFIRMED`: evento e agendamento confirmados; mensagens só são enviadas se houver inbound do cliente nas últimas 22h (janela operacional de segurança).
- `CANCELLED`: cancelado manualmente (cliente/dono) ou por timeout de `TENTATIVE`.
- `EXPIRED`: `PENDING` sem mensagem durante o TTL; libera o horário sem criar evento.

Cada `Appointment` recebe um `token` que deve ser inserido no texto disparado pelo cliente (`CONFIRMAR {TOKEN} {DATA_LOCAL}`) para validar o fluxo no webhook. Manter índice de sessão por `(tenantId, phoneE164)` com `lastInboundAt/lastOutboundAt` para o guard de 22h.

### 1.2 Modelos auxiliares (sessão e auditoria)

SessionIndex (por telefone + tenant):

```json
{
  "phoneE164": "+55DDDNUMERO",
  "tenantId": "uuid",
  "lastInboundAt": "2025-10-03T20:15:00Z",
  "lastOutboundAt": "2025-10-03T20:16:10Z",
  "remindersOpt": "on | off | unknown"
}
```

AttemptLog (auditoria dos bloqueios do guard):

```json
{
  "attemptedAt": "ISO",
  "tenantId": "uuid",
  "phoneE164": "+55DDDNUMERO",
  "type": "CONFIRMATION | REMINDER | OTHER",
  "allowed": false,
  "reason": "NO_RECENT_INBOUND_22H | OPT_OUT | PLAN_DISABLED | OTHER"
}
```

## 2. Autenticação e Controle de Acesso
- Login exclusivo com Google OAuth pelo Firebase (`src/app/login/LoginForm.tsx`).
- Proteção do dashboard/APIs via `authenticateRequest` (cookie de sessão ou bearer token). Rotas de serviço (ex.: cron) podem usar `DASHBOARD_TOKEN`.
- Endpoints públicos de agendamento (`/agenda/[slug]` e legado `/[slug]`) não exigem autenticação.

## 3. Catálogo de Planos, Limites e Enforcement

### 3.1 Estrutura canônica do plano
```json
{
  "planId": "free | starter | pro",
  "displayName": "string",
  "priceBRL": 0,
  "limits": {
    "maxConnectedCalendars": 1,
    "maxAppointmentsPerMonth": 50,
    "whatsappMessagesIncludedPerMonth": 50,
    "maxAutoRemindersPerAppointment": 0
  },
  "features": {
    "paymentAtBooking": false,
    "reviewsGoogle": false,
    "noShowPaymentOption": false
  },
  "overage": {
    "whatsappMessageBRL": null
  }
}
```

### 3.2 Planos (valores atuais)
```json
[
  {
    "planId": "free",
    "displayName": "Free",
    "priceBRL": 0,
    "limits": {
      "maxConnectedCalendars": 1,
      "maxAppointmentsPerMonth": 50,
      "whatsappMessagesIncludedPerMonth": 50,
      "maxAutoRemindersPerAppointment": 0
    },
    "features": {
      "paymentAtBooking": false,
      "reviewsGoogle": false,
      "noShowPaymentOption": false
    },
    "overage": { "whatsappMessageBRL": null }
  },
  {
    "planId": "starter",
    "displayName": "Starter",
    "priceBRL": 49,
    "limits": {
      "maxConnectedCalendars": 3,
      "maxAppointmentsPerMonth": 300,
      "whatsappMessagesIncludedPerMonth": 300,
      "maxAutoRemindersPerAppointment": 2
    },
    "features": {
      "paymentAtBooking": true,
      "reviewsGoogle": false,
      "noShowPaymentOption": true
    },
    "overage": { "whatsappMessageBRL": 0.19 }
  },
  {
    "planId": "pro",
    "displayName": "Pro",
    "priceBRL": 99,
    "limits": {
      "maxConnectedCalendars": 20,
      "maxAppointmentsPerMonth": 1000,
      "whatsappMessagesIncludedPerMonth": 1000,
      "maxAutoRemindersPerAppointment": 3
    },
    "features": {
      "paymentAtBooking": true,
      "reviewsGoogle": true,
      "noShowPaymentOption": true
    },
    "overage": { "whatsappMessageBRL": 0.17 }
  }
]
```

### 3.3 Regras globais (sem tecnicês)
- Somente WhatsApp; nunca iniciar conversa; regra operacional de 22h (inbound ≤ 22h).
- Remetente único: número central ou BYON do tenant.
- Pagamento no ato (quando ativado): pós `paid|approved` → `CONFIRMED` imediato.

### 3.4 Enforcement por plano
- `maxConnectedCalendars`: bloquear vínculos além do limite.
- `maxAppointmentsPerMonth`: negar novas criações ao atingir o teto, orientando upgrade.
- `whatsappMessagesIncludedPerMonth`:
  - Contagem por mensagem enviada pelo sistema (respostas autorizadas pelo guard 22h).
  - Free: bloquear acima da franquia (sem overage).
  - Starter/Pro: permitir excedente cobrando `overage.whatsappMessageBRL` por mensagem.
- `maxAutoRemindersPerAppointment`: respeitar o máximo de lembretes automáticos por agendamento (guard 22h e opt-in obrigatórios).

## 4. Integração com Google Agenda
- OAuth (`/api/google/oauth/start`) exige usuário autenticado.
- Callback troca o código por tokens (`googleTokens`) e, se não houver agendas, vincula automaticamente o calendário primário com slug único, descrição padrão e WhatsApp de fallback (`OWNER_DEFAULT_PHONE`).
- Cartão "Minha agenda" (`CalendarsCard`) lista calendários, permite vincular/atualizar/remover/ativar com limites por plano e cooldown de 24h (`CALENDAR_SWAP_INTERVAL_MS`).
- `createGoogleCalendarEvent` cria eventos com fuso `DEFAULT_CALENDAR_TIMEZONE` (ou override) e lembretes manuais (email 24h + popup 10 min). O texto do evento inclui cliente, WhatsApp, descrição da agenda e link público.

## 5. Fluxo Público de Agendamento + Confirmação via WhatsApp
- Remover o fluxo legado `/[slug]` e rotas associadas (`/api/professional*`). O único caminho suportado passa por `/agenda/[slug]` + `AppointmentForm`.
- `/api/appointment` deve continuar validando disponibilidade, slug, plano ativo e taxa de requisições, mas agora responder com `status=PENDING`, `token`, `holdTTL`, `confirmationMode` e o link `wa.me` para o cliente iniciar a conversa.
- Não enviar mensagens proativas antes da primeira mensagem do cliente. Sem templates/fallback: nunca iniciar conversa.

### 5.1 Modo automático (`confirmationMode=auto_on_customer_msg`)
1. Front abre `wa.me/{whatsappNumber}?text=CONFIRMAR%20{TOKEN}%20{DATA_LOCAL}` imediatamente após criar o `Appointment`.
2. Webhook `/api/webhooks/wa` valida `hub.verify_token`, normaliza o payload (`entry[].changes[].value.messages[0]`), extrai `token` via regex e confere se está dentro de `holdTTL`.
3. Antes de confirmar, revalida conflitos: se já existir evento/compromisso, responde orientando a remarcar.
4. Atualiza o Google Calendar (`status="confirmed"`, `extendedProperties.private.token`) e grava `googleEventId`.
5. Atualiza o `Appointment` para `CONFIRMED`, preenche `consentAt` e envia a mensagem consolidada (data local + links) somente se a sessão estiver válida pelo guard 22h (inbound ≤ 22h).

### 5.2 Modo manual (`confirmationMode=manual_by_owner`)
1. Passos 1–2 iguais ao modo automático.
2. Backend cria evento `status="tentative"` com `extendedProperties.private.token` e registra `Appointment=status=TENTATIVE`.
3. Painel gera link seguro `approve?token=` para dono/staff aprovarem.
4. Aprovação → `events.patch` (`status="confirmed"`), `Appointment → CONFIRMED`, envio da confirmação no WhatsApp apenas se o guard 22h permitir (inbound ≤ 22h).
5. Rejeição ou timeout (`tentativeAutoCancelHours`) → remover evento, marcar `CANCELLED` e, se houver sessão ativa, avisar o cliente.

### 5.3 Expiração, cancelamento e reagendamento
- `holdTTLMinutes`: expira `PENDING` sem mensagem → `EXPIRED`, sem eventos criados.
- Cancelamentos vindos do cliente ou painel → `CANCELLED`, remover evento e, se o guard 22h permitir, responder com confirmação do cancelamento.
- Reagendamentos precisam solicitar uma nova mensagem do cliente caso a janela gratuita tenha fechado; fornecer CTA que abre `wa.me` com `ok` pré-preenchido.

### 5.4 Mensageria, consentimento e auditoria
- Persistir todas as mensagens em `MessageLog` (`direction`, `status`, `waMessageId`, `payload.raw`).
- Preencher/atualizar `consentAt` na primeira mensagem recebida.
- Validar opcionalmente `X-Hub-Signature-256` com `META_APP_SECRET`; logar divergências.
- Métricas mínimas: taxa de confirmação, tempo P95 de `PENDING→CONFIRMED`, bloqueios do guard 22h, % expirados.

### 5.5 Itens a remover/atualizar
- Remover integrações `zapi`/`twilio` e respectivas variáveis (`WHATS_PROVIDER`, `Z_API_*`, `TWILIO_*`).
- Atualizar mocks/tests para o payload da Cloud API.
- Ajustar copies/landing/painel para comunicar confirmação via WhatsApp Cloud API e janela operacional de 22h (margem de segurança).
- Expor no dashboard os estados `PENDING`, `TENTATIVE`, `CONFIRMED`, `CANCELLED` e `EXPIRED` com links para o log de mensagens.

## 6. Notificações e Lembretes
- `sendWhats` deve usar apenas WhatsApp Cloud API (Meta). Remover seletores de provedor; manter `mock` apenas para testes.
- Guard de envio de 22h: só enviar se houver mensagem inbound do cliente para o nosso número nas últimas 22h. Nunca iniciar conversa; sem templates/fallback.
- Cron de lembretes (`/api/cron/reminder`) deve consultar o SessionIndex e AttemptLog. Se a sessão não for válida (inbound > 22h, opt-out, plano), abortar o envio e registrar.
- Registrar cada envio/bloqueio: `MessageLog` (mensagens) e `AttemptLog` (bloqueios). Ajustar dependência de `@/lib/professionals` para usar dados do `LinkedCalendar`/`Account`.
- Fluxo de feedback pós-atendimento: aplicar o mesmo guard (22h) e não iniciar conversa.

### 6.1 Guard de envio (assinatura sugerida)

Assinatura textual: `canSendWhatsApp(tenantId, phoneE164, messageType) -> { allowed: boolean, reason?: string }`.

Ordem de checagem:
- Plano do tenant permite o tipo de envio? (ex.: lembretes habilitados no plano e nas preferências)
- Consentimento do cliente (`remindersOpt == "on"`)
- Sessão válida (`now - lastInboundAt <= 22h`)
- Roteamento do remetente correto (central ou BYON configurado)
- Franquia de mensagens disponível OU overage permitido (Starter/Pro)

## 7. Cobrança do SaaS e Painéis Internos
- Dashboard `/dashboard/plans` oferece upgrade, porém:
  - Integração com Stripe Checkout ausente (usa `client_secret` incorretamente).
  - Fluxo Pix não tem página para QR/status; não há polling para confirmar pagamento.
- Nada exibe histórico de pagamentos/assinaturas no dashboard, embora os dados estejam no Firestore.
- Downgrade automático em caso de Pix vencido depende de webhook manual; não há lógica auxiliar.

## 8. Persistência de Dados e Ambiente
- Firestore é opcional; sem credenciais os dados ficam em arquivos locais (ineficiente para produção multi-instância).
- Variáveis críticas: `DEFAULT_CALENDAR_TIMEZONE`, `APP_BASE_URL`, `NEXT_PUBLIC_APP_BASE_URL`, chaves Firebase, Stripe e WhatsApp Cloud API (`WA_META_TOKEN`, `WA_PHONE_NUMBER_ID`, `WA_WABA_ID`, `WA_VERIFY_TOKEN`, `WA_GRAPH_BASE`). Para pré-pagamento, incluir `paymentWebhookSecret` (por PSP) e valores padrão de `paymentWebhookTimeoutMinutes`.
- Adicionar `META_APP_SECRET` quando for implementar a validação da assinatura do webhook.
- Remover variáveis legadas de provedores (`WHATS_PROVIDER`, `Z_API_*`, `TWILIO_*`).

### 8.1 Dados de assinatura/uso por tenant
```json
{
  "tenantId": "uuid",
  "planId": "free | starter | pro",
  "currentPeriodStart": "ISO",
  "currentPeriodEnd": "ISO",
  "usage": {
    "appointmentsMonth": 0,
    "whatsAppMessagesMonth": 0
  },
  "billing": {
    "overageWhatsAppBRL": 0
  }
}
```
- Reset de `usage` no início de cada período; `overageWhatsAppBRL` exibido no painel (Starter/Pro).

## 9. Pendências Conhecidas
1. **Módulo de profissionais** removido mas ainda referenciado (rotas/cron/landing legacy quebrados).
2. **Disponibilidade** fixa em 60 min caso o calendário não defina `slotDurationMinutes`.
3. **UX de pagamento** incompleta (cartão/Pix) e ausência de histórico.
4. **Participantes Google**: só email do dono; cliente não recebe convite.
5. **Slug de agenda**: auto-link pode colidir; uso de random fallback limitado.
6. **Lembrete para dono**: cron usa dados inexistentes (profissional), logo aviso pode não sair.
7. **Feedback WhatsApp**: não implementado.
8. **Mensageria**: migrar totalmente para Cloud API (contratos/payloads novos) e remover referências a Z-API/Twilio.
9. **Tratamento de erros**: falhas de API Google ou WhatsApp não aparecem para o cliente; agendamento pode quebrar silenciosamente.
10. **Fusos horários**: apenas default global; nada configurável por agenda.
11. **Segurança**: cron acessível para qualquer sessão autenticada; ideal exigir token de serviço.

## 13. Cobrança e Excedentes (Contratos)
- Free: bloquear envios acima do incluído.
- Starter/Pro: permitir overage a `overage.whatsappMessageBRL`; exibir contadores em tempo real e consolidar no fechamento do ciclo.

Registro mínimo de faturamento (exemplo):
```json
{
  "tenantId": "uuid",
  "periodStart": "ISO",
  "periodEnd": "ISO",
  "planId": "starter",
  "basePriceBRL": 49,
  "whatsAppIncluded": 300,
  "whatsAppUsed": 420,
  "overageUnitBRL": 0.19,
  "overageQty": 120,
  "overageTotalBRL": 22.8,
  "totalBRL": 71.8
}
```

## 14. Flags e Erros Padrão
- `ERR_PLAN_LIMIT_REACHED` (appointments/calendars/messages)
- `ERR_PLAN_FEATURE_DISABLED` (ex.: lembretes/pagamento no ato)
- `ERR_WA_SESSION_TOO_OLD` (falha na regra 22h)
- `ERR_WA_OPT_OUT` (cliente desativou lembretes)
- `ERR_OVERAGE_NOT_ALLOWED` (Free tentando excedente)

## 15. Auditoria & LGPD (mínimo)
- Consentimento de lembretes no WhatsApp: armazenar `remindersOpt="on"`, `optSource` (ex.: botão/keyword) e `optAt` (ISO) por telefone+tenant.
- AttemptLog: manter motivos padronizados de bloqueio pelo guard (ex.: `NO_RECENT_INBOUND_22H`, `PLAN_DISABLED`, `OPT_OUT`).
- Retenção de logs por período razoável; anonimização quando aplicável; nenhum dado sensível de cartão deve ser armazenado.

## 10. Checklist para Fechar o Fluxo Atual
- [ ] Permitir configurar `slotDurationMinutes` e `workHours` diretamente pelo painel (já em andamento).
- [ ] Ajustar `/api/availability` e formulários para usar `slotDurationMinutes` e janelas de trabalho.
- [ ] Implementar corretamente o fluxo de pagamento SaaS (Stripe Elements/Checkout + Pix page) e exibir histórico.
- [ ] Dar visibilidade aos pagamentos em dashboards (filtros, exportação).
- [ ] Concluir migração para WhatsApp Cloud API (env vars, payloads, webhook `hub.verify_token`).
- [ ] Implementar pagamento no ato do agendamento: checkout obrigatório quando habilitado, webhook idempotente e atualização automática do Calendar.
- [ ] Implementar catálogo de planos (Free/Starter/Pro) com enforcement: limites de calendários/agendamentos/mensagens e overage.
- [ ] Exibir contadores de uso no dashboard (incluído, usado, excedente estimado) e erros padrão (ex.: `ERR_WA_SESSION_TOO_OLD`, `ERR_OVERAGE_NOT_ALLOWED`).
- [ ] Consertar cron de lembretes e fontes de dados do dono.
- [ ] Implementar fluxo de feedback pós-consulta via WhatsApp.
- [ ] Melhorar UX de reautenticação Google (tokens revogados, erros).
- [ ] Logar/monitorar falhas de WhatsApp.

## 11. Pagamento no Ato do Agendamento (pré-pagamento opcional)

### Objetivo
- Permitir que serviços/agendas cobrem antecipadamente e confirmem a reserva assim que o PSP sinalizar pagamento aprovado.
- Manter o botão "Abrir WhatsApp" como canal opcional para comunicações gratuitas, sem torná-lo obrigatório para concluir a confirmação.

### Extensões de Modelo
```ts
// ProviderSettings
paymentAtBookingEnabled: boolean; // default false
paymentProvider?: "stripe" | "mercadopago" | "pagarme" | "other";
paymentWebhookSecret?: string;
paymentWebhookTimeoutMinutes?: number; // default 15

// LinkedCalendar (por agenda)
slotDurationMinutes?: number;
paymentAtBookingEnabled?: boolean;
paymentProvider?: "stripe" | "mercadopago" | "pagarme" | "other";
paymentCurrency?: string; // default BRL
paymentAmountCents?: number;

// Appointment
paymentRequired?: boolean;
paymentStatus?: "PENDING" | "REQUIRES_ACTION" | "PAID" | "FAILED" | "REFUNDED";
paymentProvider?: "stripe" | "mercadopago" | "pagarme" | "other";
paymentIntentId?: string | null;
paymentAmount?: number; // centavos
paymentCurrency?: string; // ex.: BRL
paidAt?: string | null;
refundAt?: string | null;
refundAmount?: number; // centavos
```
- Armazenar apenas IDs/valores; nunca persistir dados sensíveis de cartão (PCI).

### Regras de Negócio
1. **Confirmação imediata pós-pagamento**
   - Webhook do PSP com `status in ["paid", "approved"]` atualiza `Appointment.status = CONFIRMED`, `paymentStatus = PAID`, preenche `paidAt`, cria/atualiza evento no Google Calendar com `status="confirmed"` e `extendedProperties.private.paymentIntentId`.
   - Processamento idempotente usando `paymentIntentId`.
2. **Aprovação opcional do dono**
   - Painel/evento podem oferecer botão "Confirmar novamente". A ação deve ser idempotente, não alterando o estado se já estiver `CONFIRMED`.
3. **Fluxo WhatsApp**
- O CTA "Abrir WhatsApp" continua disponível para o cliente iniciar a sessão e permitir mensagens gratuitas dentro da janela operacional de 22h (inbound recente).
   - Não é obrigatório para concluir a confirmação quando o pagamento foi aprovado.
4. **Expiração do HOLD TTL**
   - Antes do checkout: segue `PENDING` com `holdTTLMinutes` padrão.
   - Ao iniciar checkout, estender TTL até `paymentWebhookTimeoutMinutes` (ex.: +15 min). Se o PSP não confirmar dentro da janela, marcar `EXPIRED` e liberar o slot.
5. **Cancelamento e reembolso**
   - Cancelamentos pós-pagamento devem atualizar `paymentStatus` (`REFUND_REQUESTED`/`REFUNDED` se adotados), registrar `refundAt`/`refundAmount` e refletir no Calendar.
   - Políticas de reembolso são configuráveis pelo Provider; ZapAgenda apenas registra o resultado.
6. **No-show**
   - `NO_SHOW` pode coexistir com pagamento concluído; eventuais multas/estornos parciais são tratados fora do escopo deste adendo.

### Contratos e Integração
- **Webhook PSP → ZapAgenda**: endpoint autenticado por `paymentWebhookSecret`. Eventos `paid|approved` confirmam o agendamento. Eventos `failed|canceled` marcam `paymentStatus=FAILED` mantendo `PENDING` até o TTL expirar.
- **Checkout**: `/api/appointment` deve retornar instruções do PSP (ex.: `client_secret`, `preferenceId`) quando `paymentRequired=true`, além de informar o tempo restante (`paymentWebhookTimeoutMinutes`).
- **Google Calendar**: utilizar o contrato existente, apenas garantindo `status="confirmed"` e armazenando `paymentIntentId` em `extendedProperties.private`.
- **Mensageria**: se houver sessão válida (guard 22h), enviar mensagem de confirmação pós-pagamento. Sem sessão válida, não enviar nada por WhatsApp.

### 11.1 Integração com Planos
- Se `features.paymentAtBooking == true` no plano do tenant e a agenda estiver com a opção ativada, confirmar automaticamente após `paid|approved`.
- Mensagem de confirmação no WhatsApp somente se o guard 22h permitir; aprovação manual do Provider continua opcional e idempotente.

### Segurança e Compliance
- Validar a assinatura/secret de todos os webhooks do PSP.
- Registrar consentimento e termos de reembolso aceitos pelo cliente.
- Garantir que nenhuma informação de cartão passe pelo backend (usar checkout hospedado ou SDKs do PSP).

### Estados e Transições (pagamento habilitado)
```
PENDING --(checkout iniciado)-------------> PENDING (TTL estendido)
PENDING --(PSP paid/approved)------------> CONFIRMED (paymentStatus=PAID)
PENDING --(TTL expira sem pagar)---------> EXPIRED
CONFIRMED --(cancel + refund aprovado)-> CANCELLED (paymentStatus=REFUNDED opcional)
```
- Aprovação manual continua opcional e idempotente após confirmação via pagamento.

---
Este documento deve ser revisado conforme módulos forem concluídos (profissionais, pagamentos completos, etc.).

## 12. Plano de Implementação Priorizado

Abaixo, um roteiro sugerido para atacar as pendências sem travar o desenvolvimento:

1. **Estabilizar a base de agendamentos**
   - Reintroduzir dados de serviços/horários diretamente a partir dos calendários vinculados.
   - Atualizar `/api/availability` e os formulários públicos para usar duração por serviço e bloquear horários fora do expediente.
   - Garantir que o cron de lembretes funcione sem dependências quebradas.

2. **Corrigir fluxos críticos existentes**
   - Ajustar o módulo de pagamentos SaaS (Stripe Elements/Checkout + página Pix) e exibir histórico no dashboard.
   - Completar a migração para WhatsApp Cloud API: remover código legado, validar webhook (`hub.verify_token`/`X-Hub-Signature-256`) e ajustar mensageria PENDING/TENTATIVE/CONFIRMED.
   - Revisar a segurança das rotas sensíveis (cron, APIs internas) adicionando token de serviço quando necessário.
   - Melhorar o tratamento de erros e os logs em integrações externas (Google e WhatsApp).

3. **Entregar o pagamento no ato do agendamento**
   - Estender `ProviderSettings`/`Service`/`Appointment` com campos `paymentAtBookingEnabled`, `paymentStatus`, `paymentIntentId`, etc.
   - Ajustar `/api/appointment` para sinalizar `paymentRequired`, devolver credenciais de checkout e estender o `holdTTL` enquanto o pagamento está em curso.
   - Implementar webhook do PSP (Stripe/MercadoPago/Pagar.me) validando assinatura, confirmando automaticamente o evento no Google Calendar e registrando `paidAt`/`refundAt`.
   - Atualizar dashboard/painel para exibir status de pagamento (`PENDING`, `PAID`, `FAILED`, `REFUNDED`) e ações de cancelamento/reembolso.

4. **Automação pós-atendimento e experiência do cliente**
   - Implementar o fluxo de feedback via WhatsApp.
   - Adicionar convites por e-mail (cliente como attendee) e melhorias de UX nas telas públicas.

5. **Relatórios e finalização**
   - Exportações CSV, visões de faturamento e painéis consolidados.
   - Revisar documentação, `.env` e instruções de deploy.

Seguir essa ordem minimiza retrabalho: primeiro estabiliza o core de agendamento, depois corrige monetização existente, em seguida adiciona o novo pré-pagamento (que depende das etapas anteriores) e, por fim, trabalha na camada de experiências avançadas e relatórios.


# ZapAgenda

This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).


Last updated: 2025-10-03 09:00

[![Deployed on Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/mgotze/zapagenda)

## Atualizações recentes (Out/2025)

- WhatsApp Cloud API (Meta) habilitado; Z-API/Twilio removidos. Variáveis: `WA_META_TOKEN`, `WA_PHONE_NUMBER_ID`, `WA_WABA_ID`, `WA_VERIFY_TOKEN`, `WA_GRAPH_BASE`.
- Regra operacional de 22h: só respondemos se houve inbound ≤ 22h; nunca iniciamos conversa.
- Pagamento no ato (opcional): `paymentAtBookingEnabled` confirma automaticamente após webhook `paid|approved`.
- Novos planos: Free (R$ 0), Starter (R$ 49), Pro (R$ 99) com limites por plano (calendários, agendamentos/mês, mensagens WhatsApp incluídas) e overage por mensagem no Starter/Pro.
- Build/deploy seguem com Yarn Classic (`yarn install`, `yarn dev`, `yarn build`).

## Próximos passos

- Substituir o código legado do provedor WhatsApp pelos contratos Meta: remover chamadas `Z_API_*`, `WHATS_PROVIDER=zapi` e adaptar payloads para `messages`/`entry.changes`.
- Rodar `yarn build` e validar um deploy pós-alterações (Stripe/Pix + ícone do calendário).
- Garantir que o webhook `/api/webhooks/wa` valide `hub.verify_token` e registre mensagens (entrada/saída) com consentimento LGPD.
- Implementar o checkout obrigatório quando `paymentAtBookingEnabled=true`, garantindo confirmação automática e idempotente após o webhook do PSP.
- Atualizar vitrine/landing para refletir Free/Starter/Pro, limites e overage.
- Testar em staging o downgrade automático: simular falha/cancelamento de cobrança e checar agendas bloqueadas.
- Criar dashboards métricos para monitorar upgrades/downgrades e custos de mensagens (sem templates), taxa de bloqueios pelo guard 22h.

## Getting Started

First, run the development server (Yarn Classic only):

```bash
yarn install
yarn dev
```

> ⚠️ Utilizamos apenas Yarn 1 (`1.22.x`). Evite `npm`, `pnpm` ou `bun` para não quebrar o lockfile e o build em produção.

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Regras do sistema

- As regras são versionadas por data em `rules/`. Sempre consulte a mais recente.
- Documento mais recente: `rules/2025-10-03.md`.
- Também há uma página interna no app: acesse `/regras`.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

## Local testing quickstart

1. Copie `.env.local.example` para `.env.local` (ou `.env.example` caso prefira) e ajuste os valores. Para testes locais sem integração real, use valores fictícios para `WA_META_TOKEN`, `WA_PHONE_NUMBER_ID`, `WA_WABA_ID`, defina `paymentWebhookSecret` dummy e mantenha `DASHBOARD_TOKEN=localtoken`. Remova `WHATS_PROVIDER` do template assim que o código migrar totalmente para Cloud API.
2. Configure Firebase:
   - **Admin SDK**: `FIREBASE_PROJECT_ID`, `FIREBASE_CLIENT_EMAIL`, `FIREBASE_PRIVATE_KEY` (service account) para Firestore.
   - **Client/Web SDK**: chaves `NEXT_PUBLIC_FIREBASE_*` geradas ao criar um app Web no console (ex.: `NEXT_PUBLIC_FIREBASE_API_KEY`). Sem elas o login não carrega.
3. Inicie o projeto com `yarn dev` e acesse:
   - Landing page: `http://localhost:3000/` (CTA para login/admin).
   - Login/Dashboard: `http://localhost:3000/login` (use um usuário criado no Firebase Auth). Após autenticar, conecte o Google Calendar em `/dashboard?tab=agenda` e copie o link público em `/agenda/{slug}`.
4. Para acionar manualmente o lembrete de WhatsApp, execute `yarn cron:reminder`. Caso use token de serviço, envie `Authorization: Bearer <DASHBOARD_TOKEN>`; senão, autentique via Firebase e use um ID token válido.
5. Verifique os resultados:
   - Leads em dev: arquivo `leads.dev.json`.
   - Agendamentos locais: `data/appointments.json` (criado automaticamente).
   - Logs do provedor mock: console do servidor (`[whats:mock]`).

### Checklist de testes manuais

Execute os passos abaixo sempre que configurar um novo ambiente ou antes de fazer deploy:

1. **Lead** — Na landing (`/`), envie um e-mail; confirme a resposta 200 e a presença do registro no Firestore (`leads`) ou `leads.dev.json`.
2. **Agendamento** — Vincule uma agenda Google e use o link público (`/agenda/{slug}`) para criar um agendamento de teste. Verifique:
   - resposta `ok: true`;
   - log `[whats:mock]` no terminal (ou mensagem real se estiver usando um provedor).
3. **Dashboard** — Autentique-se em `/dashboard` e confirme se o agendamento recém-criado aparece. Teste filtros por agenda, período e busca.
4. **Cron** — Execute `yarn cron:reminder`; se houver agendamentos dentro da janela configurada, o comando deve registrar envios e marcar `reminderSentAt` no dashboard.
5. **Rate limit** — Use o formulário de lead repetidamente para garantir que o erro 429 seja retornado após exceder o limite (opcional, mas recomendado).

## Firebase & produção

1. Gere uma Service Account com acesso ao Firebase Admin e preencha `FIREBASE_PROJECT_ID`, `FIREBASE_CLIENT_EMAIL` e `FIREBASE_PRIVATE_KEY` em `.env.local` (não comite esse arquivo).
2. Aplique as regras/base de índices fornecidas neste repositório:
   ```bash
   firebase deploy --only firestore:rules,firestore:indexes --project <seu-projeto>
   ```
   (ou use o painel web copiando `firebase/firestore.rules` e `firebase/firestore.indexes.json`).
3. Configure OAuth do Google (agendas):
   - Defina `GOOGLE_CLIENT_ID` e `GOOGLE_CLIENT_SECRET` nas variáveis de ambiente.
   - Opcional: `GOOGLE_REDIRECT_URI` (padrão é `${APP_BASE_URL}/api/google/oauth/callback`).
   - No console de APIs do Google, autorize o URI de redirecionamento.
   - Após autenticar no app, acesse `Dashboard → Minha agenda` e clique em “Conectar com Google” para listar e vincular calendários.
5. Configure um agendador para chamar `/api/cron/reminder` em produção (ex.: Vercel Scheduler ou Cloud Scheduler). Exemplo Vercel:
   - URL: `https://seu-dominio.vercel.app/api/cron/reminder`
   - Método: `POST`
   - Cabeçalho: `Authorization: Bearer <DASHBOARD_TOKEN>`
   - Frequência: conforme necessidade (ex.: a cada 15 minutos).
6. Ajuste os parâmetros de lembrete (`REMINDER_WINDOW_MINUTES`, `REMINDER_NOTIFY_OWNER`) e configure as credenciais do WhatsApp Cloud API no `.env` (`WA_META_TOKEN`, `WA_PHONE_NUMBER_ID`, `WA_WABA_ID`, `WA_VERIFY_TOKEN`, `WA_GRAPH_BASE=https://graph.facebook.com/v20.0`). Remova variáveis antigas de provedores descontinuados (Z-API/Twilio).

### Novas regras de confirmação via WhatsApp (janela de segurança 22h)

- `Appointment` nasce como `PENDING`; ao receber mensagem do cliente dentro do `holdTTL` vira `CONFIRMED` (modo automático) ou `TENTATIVE` (modo manual) até aprovação.
- Sempre gerar o link `wa.me/{numero}?text=CONFIRMAR%20{TOKEN}%20{DATA_LOCAL}` ao final do agendamento; nunca iniciar conversa. Somente enviar mensagens quando houver inbound do cliente nas últimas 22h.
- Removido o uso de templates pagos/fallback: se passaram 22h sem inbound, não enviar nada por WhatsApp.
- Logue todas as mensagens na coleção `MessageLog` com direção/status e `waMessageId` para garantir rastreabilidade.

### Guard de envio (22h) e auditoria

- Antes de qualquer envio (confirmação, lembrete), verificar: plano permite, consentimento do cliente, e sessão válida (inbound ≤ 22h) para o número correto (central/BYON).
- Modelos auxiliares:
  - SessionIndex: `{ phoneE164, tenantId, lastInboundAt, lastOutboundAt, remindersOpt }`.
  - AttemptLog: `{ attemptedAt, tenantId, phoneE164, type, allowed, reason }`.

### Pagamento no ato do agendamento (opcional)

- Habilite via `ProviderSettings.paymentAtBookingEnabled` ou por serviço; defina `paymentProvider`, `currency`/`amount` (centavos) e `paymentWebhookSecret`.
- `/api/appointment` deve sinalizar `paymentRequired=true` e devolver dados de checkout (ex.: `client_secret`) quando a flag estiver ativa.
- O PSP chama o webhook com `status in ["paid","approved"]`; confirmar `Appointment` e evento Google imediatamente (`status="confirmed"`, `paymentIntentId`).
- Mantenha `holdTTLMinutes` até o checkout; ao iniciar o pagamento, estenda até `paymentWebhookTimeoutMinutes` para evitar expiração prematura.
- Cancelamentos pagos devem registrar `refundAmount`, `refundAt` e, quando aplicável, ajustar `paymentStatus=REFUNDED`.

# Regras — 2025-10-03

Este documento registra as regras de negócio vigentes a partir de 2025-10-03. Não edite documentos anteriores; ajuste sempre criando um novo arquivo datado.

## Planos e ciclo de vida da conta
- Conta nova inicia no plano `free` e status ativo (sem período de teste).
- O plano `free` é sempre considerado ativo para efeitos de uso do sistema (pode agendar nos limites do plano).
- Compra/upgrade de plano só é permitida após login. Usuários não autenticados são redirecionados para `/login` com mensagem de “login requerido”.
- Ao perder cobrança/recorrência ou cancelar a assinatura, a conta volta para `free` automaticamente e permanece ativa. Exibir aviso de downgrade e encaminhar para `/dashboard/plans` para novo upgrade.

## Agendamento público (link compartilhável)
- Cada agenda pode ter um token público (`publicToken`).
- Quando `publicToken` existir, o link público obrigatório é `/agenda/:slug/:h` (onde `:h` é o token). O caminho sem token não deve funcionar.
- APIs públicas exigem o token:
  - Disponibilidade: `GET /api/availability?slug=...&date=YYYY-MM-DD&h=...`
  - Criar agendamento: `POST /api/appointment` com `{ slug, h, ... }`.
- Se o token não for válido/ausente, retornar erro genérico: “Agenda não encontrada ou link inválido.”
- O dono pode regenerar o token pelo dashboard (invalida links anteriores).

## Logotipo da agenda
- Até segunda decisão, arquivos ficam no repositório em `public/agenda-logos/{slug}/`.
- O caminho do logo é salvo em `linkedCalendars[].logoPath` (ex.: `/agenda-logos/{slug}/logo.webp`).
- Exibição nas páginas públicas usa o `logoPath`; fallback para `/logos/calendar.png`.

## Regras de agendamento e UX
- Bloquear datas/horários passados com base no fuso do cliente; mensagem: “Escolha um horário no futuro.”
- Internamente, falhas de infraestrutura/billing do dono não devem aparecer ao cliente. Mensagem padrão: “Agenda indisponível no momento. Tente novamente mais tarde.”
- Formulário público:
  - Data mínima = hoje.
  - Seleção de horários em grid (slots livres), com estados de carregando/selecionado/indisponível.
  - WhatsApp deve ser válido em formato E.164 BR (`+55DDDNÚMERO`).

## Pagamentos e pré-pagamento por agenda
- Pré-pagamento manual (Pix/instruções) só disponível a partir do plano Starter.
- Pré-pagamento via cartão (Stripe) ainda não está habilitado no fluxo público; a API deve bloquear com erro amigável.

